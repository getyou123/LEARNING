### java历史

- 长期支持版本LTS（long term support）
- 几个重要的版本：
    - 1996年，发布JDK1.0;
    - 里程碑式的版本：JDK5.0、 JDK8.0(2014年发布）
    - JDK11 (LTS)、
    - JDK17 (LTS)

### 书籍

- effective java
- java核心技术
- java编程思想

### java技术体系平台

- java se
- java ee
- java me

### jdk jre jvm的关系

- ![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302261917388.png)
- jdk包括 jre，jre中有jvm

### java的程序的运行过程

- ![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302261920227.png)

## java注释分类

- 单行
- 多行
- 段注释
- 文档注释 用于生成说明文档

``` 
/**
 * @description: TODO
 * @author $user$
 * @date $date$ $time$
 * @version 1.0
 */

javadoc -d mydoc -author -version hello.java 会生成相应的html文件
```

### java api

- API (Application Programming Interface, 应用程序编程接口）
- 其实就是自己封装的类库，供给其他人使用
- ![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302262140576.png)

### jvm的功能

- 是底层java跨平台的本质
    - ![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302262143598.png)
- java程序员最后变成面向jvm编程
    - ![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302262144628.png)
- 自动内存管理：内存分配 内存回收
    - 也会存在内存泄漏和内存溢出oom

### java语言基础

- 关键字
- 变量
- 运算符
- 流程控制
- 数组

### 关于接口

[InterFace01.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FInterFace01.java)
[InterFace02.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FInterFace02.java)
定义了两个接口 一个是sound 另外一个是run 方法

- 接口中只有public static final 的变量，不显式声明也是
- 接口中只有public abstract 方法，不声明也是
- jdk8中可以有默认方法，如果实现类没有重写的话，就调用接口中的方法
- 类优先原则，父类的优先于接口中的默认方法

[InterFaceImpl.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FInterFaceImpl.java) 这个实现了两个接口

### 关于抽象类

- [AbstractClass01.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FAbstractClass01.java) 定义了一个抽象类，只要其中包含抽象方法要声明为抽象类
- [AbstractClass01Impl.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FAbstractClass01Impl.java) 实现了抽象类中的方法，也包含自己的变量
- 抽象类和接口的区别
    - 抽象类不能有对象，不能使用new AbstractClass01
    - 抽象类描述是不是的关系，接口描述有没有的问题
    - 抽象类需要继承，接口需要实现，多对一，一对一

### 自动拆箱装箱

- 基本的数据结构和对应的包装类是自动拆箱和装箱的
- [AutoPackage.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FAutoPackage.java)
- int i3 = Integer.parseInt(intStr);
- String intStr1 = String.valueOf(i3);

### 字符串的相关操作

- [StringLearn.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FStringLearn.java)
- 创建
- 切分
- 查找
- 获取子串

### java中的循环

```java
public class ForLoop {

    public static void main(String[] args) {

        int[] arr1 = new int[]{1, 23, 4};

        for (int i = 0; i < arr1.length; i++) {
            System.out.println(arr1[i]);
        }

        for (int i : arr1) {
            System.out.println(i);
        }

    }

}
```

### 日期相关的操作

- [DateLearn.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FDateLearn.java)
- 字符串转日期
- 日期转为字符串
- 日期移动
- 日期转时间戳

### 枚举

- [EnumLearn.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FEnumLearn.java)
- 看起来就是固定的数据

### java 异常写法

``` 
//形式1:
        try {
            语句块;
        } catch (
                异常类型1 异常对象名1) {
            处理异常代码块1;
        } catch (
                异常类型1 异常对象名1) {
            处理异常代码块1;
        }

//形式2: 
        try {
            语句块;
        } catch (异常类型1 异常对象名1) {
            处理异常代码块1;
        } catch (异常类型1 异常对象名1) {
            处理异常代码块1;
        } finally {
            最终语句块;
        }
        
//形式3: 
        try {
            语句块;
        } finally {
            最终语句块;
        }
```

### 算数左移，右移（快速计算）

10 << 1 的结果等于 20
10 << 3 的结果等于 80 （乘法）

6 >> 1 的结果等于 3
6 >> 2 的结果等于 1 （取商）

### java中的& 和 && 的区别

& 是不满足短路的，如果前面的条件失效了，还会去判断后面条件；&& 如果前面的都失效返回false了，那就不再去判断第二条件了

### 三目运算符

(条件表达式)?表达式1:表达式2

### java中如何表示金额

使用 BigDecimal

### java获取一个随机数

Math.random() 返回 [0.0,1.0)，乘以（区间长度+1）+区间下限然后转为指定的类型；比如获取[1,100]之间的一个随机数 Math.random()*(
b-a+1)+1

### 判定对象类型

if (e instanceof XXX)

### java中的深拷贝和浅拷贝

如果原型对象的成员变量是值类型，将复制一份给克隆对象，也就是说在堆中拥有独立的空间；
如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。
换句话说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。

举例来说更加清楚：
对象A1中包含对B1的引用，B1中包含对C1的引用。浅拷贝A1得到A2，A2中依然包含对B1的引用，B1中依然包含对C1的引用。
深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，B2中包含对C2（C1的copy）的引用。

浅拷贝的实现：

``` 
implements Cloneable {
然后重新clone方法
/**
 * 重写 clone 方法，需要将权限改成 public ，直接调用父类的 clone 方法就好了
*/
@Override
public Object clone() throws CloneNotSupportedException {
return super.clone();
}
```

深拷贝的实现：
```
implements Cloneable {
然后重新clone方法
/**

* 重写 clone 方法，需要将权限改成 public ，直接调用父类的 clone 方法就好了
  */
  @Override
  public Object clone() throws CloneNotSupportedException {
  Person person = (Person)super.clone();
  // 需要将引用对象也克隆一次
  person.personDesc = (PersonDesc) personDesc.clone();
  return person;
  }
```

### 面向对象编程-多态

### 面向对象编程-封装

### 面向对象编程-继承


### java中的内部类
- 在类A中又定义了一个类B
- B只给类A用，不再其他的地方用
- 高内聚，低耦合

### 基本的创建多线程的方式
1. 继承Thread类，重写run方法
   - [Thread_Learn1.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn1.java)
   - 这里展示了两个线程交替执行的情况
   - 线程的名字 默认编号的
   - 实现匿名子类的写法 [Thread_Learn2.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn2.java)
2. 实现runnable的接口
   - [Thread_Learn3.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn3.java)
   - 作为Thread的构造函数的参数构造一个Thread
   - 然后start
   - 使用匿名实现类的方式[Thread_Learn4.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn4.java)
3. 优缺点对比：
   - 核心都是Thread.start()
   - 一个是继承，一个是接口的实现，最好使用接口，因为可以多实现
   - 接口实现方式，天然的数据共享
4. Thread的一些方法：
- 设置名字
- 获取名字
- start
- run
- Thread.sleep() 暂时sleep线程
- Tread.yield() static的放弃使用cpu转为就绪态[Thread_Learn5.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn5.java)
- join方法 在线程a中调用线程b.join(),那么线程a会阻塞等待知道线程b结束[Thread_Learn6.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn6.java)

### Thread的生命周期
*   新建 New
*   就绪 Runnable
*   运行 Running
*   阻塞 Blocked
*   死亡 Dead
转换图： ![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302262359619.png)
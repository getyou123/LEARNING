### java历史

- 长期支持版本LTS（long term support）
- 几个重要的版本：
    - 1996年，发布JDK1.0;
    - 里程碑式的版本：JDK5.0、 JDK8.0(2014年发布）
    - JDK11 (LTS)、
    - JDK17 (LTS)

### 书籍

- effective java
- java核心技术
- java编程思想

### java技术体系平台

- java se
- java ee
- java me

### jdk jre jvm的关系

- ![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302261917388.png)
- jdk包括 jre，jre中有jvm

### java的程序的运行过程

- ![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302261920227.png)

## java注释分类

- 单行
- 多行
- 段注释
- 文档注释 用于生成说明文档

``` 
/**
 * @description: TODO
 * @author $user$
 * @date $date$ $time$
 * @version 1.0
 */

javadoc -d mydoc -author -version hello.java 会生成相应的html文件
```

### java api

- API (Application Programming Interface, 应用程序编程接口）
- 其实就是自己封装的类库，供给其他人使用
- ![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302262140576.png)

### jvm的功能

- 是底层java跨平台的本质
    - ![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302262143598.png)
- java程序员最后变成面向jvm编程
    - ![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302262144628.png)
- 自动内存管理：内存分配 内存回收
    - 也会存在内存泄漏和内存溢出oom

### java语言基础

- 关键字
- 变量
- 运算符
- 流程控制
- 数组

### 关于接口

[InterFace01.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FInterFace01.java)
[InterFace02.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FInterFace02.java)
定义了两个接口 一个是sound 另外一个是run 方法

- 接口中只有public static final 的变量，不显式声明也是
- 接口中只有public abstract 方法，不声明也是
- jdk8中可以有默认方法，如果实现类没有重写的话，就调用接口中的方法
- 类优先原则，父类的优先于接口中的默认方法

[InterFaceImpl.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FInterFaceImpl.java) 这个实现了两个接口

### 关于抽象类

- [AbstractClass01.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FAbstractClass01.java) 定义了一个抽象类，只要其中包含抽象方法要声明为抽象类
- [AbstractClass01Impl.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FAbstractClass01Impl.java) 实现了抽象类中的方法，也包含自己的变量
- 抽象类和接口的区别
    - 抽象类不能有对象，不能使用new AbstractClass01
    - 抽象类描述是不是的关系，接口描述有没有的问题
    - 抽象类需要继承，接口需要实现，多对一，一对一

### 自动拆箱装箱

- 基本的数据结构和对应的包装类是自动拆箱和装箱的
- [AutoPackage.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FAutoPackage.java)
- int i3 = Integer.parseInt(intStr);
- String intStr1 = String.valueOf(i3);

### 字符串的相关操作

- [StringLearn.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FStringLearn.java)
- 创建
- 切分
- 查找
- 获取子串

### java中的循环

```java
public class ForLoop {

    public static void main(String[] args) {

        int[] arr1 = new int[]{1, 23, 4};

        for (int i = 0; i < arr1.length; i++) {
            System.out.println(arr1[i]);
        }

        for (int i : arr1) {
            System.out.println(i);
        }

    }

}
```

### 日期相关的操作

- [DateLearn.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FDateLearn.java)
- 字符串转日期
- 日期转为字符串
- 日期移动
- 日期转时间戳

### 枚举

- [EnumLearn.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FEnumLearn.java)
- 看起来就是固定的数据

### java 异常写法

``` 
//形式1:
        try {
            语句块;
        } catch (
                异常类型1 异常对象名1) {
            处理异常代码块1;
        } catch (
                异常类型1 异常对象名1) {
            处理异常代码块1;
        }

//形式2: 
        try {
            语句块;
        } catch (异常类型1 异常对象名1) {
            处理异常代码块1;
        } catch (异常类型1 异常对象名1) {
            处理异常代码块1;
        } finally {
            最终语句块;
        }
        
//形式3: 
        try {
            语句块;
        } finally {
            最终语句块;
        }
```

### 算数左移，右移（快速计算）

10 << 1 的结果等于 20
10 << 3 的结果等于 80 （乘法）

6 >> 1 的结果等于 3
6 >> 2 的结果等于 1 （取商）

### java中的& 和 && 的区别

& 是不满足短路的，如果前面的条件失效了，还会去判断后面条件；&& 如果前面的都失效返回false了，那就不再去判断第二条件了

### 三目运算符

(条件表达式)?表达式1:表达式2

### java中如何表示金额

使用 BigDecimal

### java获取一个随机数

Math.random() 返回 [0.0,1.0)，乘以（区间长度+1）+区间下限然后转为指定的类型；比如获取[1,100]之间的一个随机数 Math.random()*(
b-a+1)+1

### 判定对象类型

if (e instanceof XXX)

### java中的深拷贝和浅拷贝

如果原型对象的成员变量是值类型，将复制一份给克隆对象，也就是说在堆中拥有独立的空间；
如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。
换句话说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。

举例来说更加清楚：
对象A1中包含对B1的引用，B1中包含对C1的引用。浅拷贝A1得到A2，A2中依然包含对B1的引用，B1中依然包含对C1的引用。
深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，B2中包含对C2（C1的copy）的引用。

浅拷贝的实现：

``` 
implements Cloneable {
然后重新clone方法
/**
 * 重写 clone 方法，需要将权限改成 public ，直接调用父类的 clone 方法就好了
*/
@Override
public Object clone() throws CloneNotSupportedException {
return super.clone();
}
```

深拷贝的实现：

```
implements Cloneable {
然后重新clone方法
/**

* 重写 clone 方法，需要将权限改成 public ，直接调用父类的 clone 方法就好了
  */
  @Override
  public Object clone() throws CloneNotSupportedException {
  Person person = (Person)super.clone();
  // 需要将引用对象也克隆一次
  person.personDesc = (PersonDesc) personDesc.clone();
  return person;
  }
```

### 面向对象编程-多态

### 面向对象编程-封装

### 面向对象编程-继承

### java中的内部类

- 在类A中又定义了一个类B
- B只给类A用，不再其他的地方用
- 高内聚，低耦合

---

### 并发和并行的区别

* 并行（parallel）：指两个或多个事件在同一时刻发生（同时发生）。指在同一时刻，有多条指令在多个CPU上同时执行。比如：多个人同时做不同的事
* 并发（concurrency）：指两个或多个事件在同一个时间段内发生。即在一段时间内，有多条指令在单个CPU上快速轮换、交替执行，使得在宏观上具有多个进程同时执行的效果

### 基本的创建多线程的方式

1. 继承Thread类，重写run方法
    - [Thread_Learn1.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn1.java)
    - 这里展示了两个线程交替执行的情况
    - 线程的名字 默认编号的
    - 实现匿名子类的写法 [Thread_Learn2.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn2.java)
2. 实现runnable的接口
    - [Thread_Learn3.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn3.java)
    - 作为Thread的构造函数的参数构造一个Thread
    - 然后start
    - 使用匿名实现类的方式[Thread_Learn4.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn4.java)
3. 优缺点对比：
    - 核心都是Thread.start()
    - 一个是继承，一个是接口的实现，最好使用接口，因为可以多实现
    - 接口实现方式，天然的数据共享
4. Thread的一些方法：

- public Thread(Runnable target,String name)  设置名字创建线程
- 获取名字
- start
- run
- public static Thread currentThread()
- public static void sleep(long millis) 暂时sleep线程
- public static void yield()
  static的放弃使用cpu转为就绪态[Thread_Learn5.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn5.java)
- join方法 在线程a中调用线程b.join()
  ,那么线程a会阻塞等待知道线程b结束[Thread_Learn6.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn6.java)，void
  join(long millis) 加了等待时间的参数
- getPriority 获取线程的优先级 优先级 1-10
- setPriority 设置线程的优先级 ![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302271445049.png)
  高优先级的线程有更大的概率得到cpu的调度
- void suspend() / void resume() 已经过时，挂起和唤醒

---

### 守护线程

有一种线程，它是在后台运行的，它的任务是为其他线程提供服务的，这种线程被称为“守护线程”。JVM的垃圾回收线程就是典型的守护线程。

守护线程有个特点，就是如果所有非守护线程都死亡，那么守护线程自动死亡。形象理解：`兔死狗烹`，`鸟尽弓藏`

调用setDaemon(true)方法可将指定线程设置为守护线程。必须在线程启动之前设置，否则会报IllegalThreadStateException异常。

调用isDaemon()可以判断线程是否是守护线程。

守护线程示例：[Thread_Learn8.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn8.java)

---

### Thread的生命周期

-------
jdk1.5之前是五种状态：

* 新建 New：就是创建时期
* 就绪 Runnable：调用了线程的start方法之后，就从新建态转为了就绪态，就是具有了竞争cpu的资格
* 运行 Running：获取cpu进入到运行态，执行其中的run方法的代码
* 阻塞 Blocked：
    * 进入阻塞态的事件：
        * 线程调用了sleep()方法，主动放弃所占用的CPU资源；
        * 线程试图获取一个同步监视器，但该同步监视器正被其他线程持有；
        * 线程执行过程中，同步监视器调用了wait()，让它等待某个通知（notify）；
        * 线程执行过程中，同步监视器调用了wait(time)
        * 线程执行过程中，遇到了其他线程对象的加塞（join）；
        * 线程被调用suspend方法被挂起（已过时，因为容易发生死锁）；
    * 对应的唤醒操作：
        * 线程的sleep()时间到；
        * 线程成功获得了同步监视器；
        * 线程等到了通知(notify)；
        * 线程wait的时间到了
        * 加塞的线程结束了；
        * 被挂起的线程又被调用了resume恢复方法（已过时，因为容易发生死锁）；
* 死亡 Dead
    * run()方法执行完成，线程正常结束
    * 线程执行过程中抛出了一个未捕获的异常（Exception）或错误（Error）
    * 直接调用该线程的stop()来结束该线程（已过时）

转化图：![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302271516238.png)
---
jdk 1.5之后 进程的状态变为了6个

``` 
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```

- `NEW（新建）`：线程刚被创建，但是并未启动。还没调用start方法。

- `RUNNABLE（可运行）`：这里没有区分就绪和运行状态。因为对于Java对象来说，只能标记为可运行，至于什么时候运行，不是JVM来控制的了，是OS来进行调度的，而且时间非常短暂，因此对于Java对象的状态来说，无法区分。

- `Teminated（被终止）`：表明此线程已经结束生命周期，终止运行。

- 重点说明，根据Thread.State的定义，**阻塞状态分为三种**：`BLOCKED`、`WAITING`、`TIMED_WAITING`。
    1. `BLOCKED（锁阻塞）`：在API中的介绍为：一个正在阻塞、等待一个监视器锁（锁对象）的线程处于这一状态。只有获得锁对象的线程才能有执行机会。
        - 比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。
    2. `TIMED_WAITING（计时等待）`：在API中的介绍为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。
        - 当前线程执行过程中遇到Thread类的`sleep`或`join`，Object类的`wait`，LockSupport类的`park`
          方法，并且在调用这些方法时，`设置了时间`，那么当前线程会进入TIMED_WAITING，直到时间到，或被中断。
    3. `WAITING（无限等待）`：在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。
        - 当前线程执行过程中遇到遇到Object类的`wait`，Thread类的`join`，LockSupport类的`park`
          方法，并且在调用这些方法时，`没有指定时间`，那么当前线程会进入WAITING状态，直到被唤醒。
            - 通过Object类的wait进入WAITING状态的要有Object的notify/notifyAll唤醒；
            - 通过Condition的await进入WAITING状态的要有Condition的signal方法唤醒；
            - 通过LockSupport类的park方法进入WAITING状态的要有LockSupport类的unpark方法唤醒
            - 通过Thread类的join进入WAITING状态，只有调用join方法的线程对象结束才能让当前线程恢复；

说明：当从WAITING或TIMED_WAITING恢复到Runnable状态时，如果发现当前线程没有得到监视器锁，那么会立刻转入BLOCKED状态。

转化图：![](https://raw.githubusercontent.com/getyou123/git_pic_use/master/zz202302271538358.png)

### 卖票示例

1.局部变量的

```java
class Window extends Thread {
    public void run() {
        int ticket = 100;
        while (ticket > 0) {
            System.out.println(getName() + "卖出一张票，票号:" + ticket);
            ticket--;
        }
    }
}

public class SaleTicketDemo1 {
    public static void main(String[] args) {
        Window w1 = new Window();
        Window w2 = new Window();
        Window w3 = new Window();

        w1.setName("窗口1");
        w2.setName("窗口2");
        w3.setName("窗口3");

        w1.start();
        w2.start();
        w3.start();
    }
}
```

结果：发现卖出300张票。

问题：局部变量是每次调用方法都是独立的，那么每个线程的run()的ticket是独立的，不是共享数据。


2. 不同对象实例的变量不共享
```java
class TicketWindow extends Thread {
    private int ticket = 100;
    public void run() {
        while (ticket > 0) {
            System.out.println(getName() + "卖出一张票，票号:" + ticket);
            ticket--;
        }
    }
}

public class SaleTicketDemo2 {
    public static void main(String[] args) {
        TicketWindow w1 = new TicketWindow();
        TicketWindow w2 = new TicketWindow();
        TicketWindow w3 = new TicketWindow();

        w1.setName("窗口1");
        w2.setName("窗口2");
        w3.setName("窗口3");

        w1.start();
        w2.start();
        w3.start();
    }
}
```

结果：发现卖出300张票。

问题：不同的实例对象的实例变量是独立的。

3. 静态变量可共享，但是没实现安全访问

```java
class TicketSaleThread extends Thread {
    private static int ticket = 100;

    public void run() {
        while (ticket > 0) {
            try {
                Thread.sleep(10);//加入这个，使得问题暴露的更明显
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(getName() + "卖出一张票，票号:" + ticket);
            ticket--;
        }
    }
}

public class SaleTicketDemo3 {
    public static void main(String[] args) {
        TicketSaleThread t1 = new TicketSaleThread();
        TicketSaleThread t2 = new TicketSaleThread();
        TicketSaleThread t3 = new TicketSaleThread();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```
运行结果：存在重复票号问题

4. 可实现方案： 
- 定义类的static变量，然后实现同步的访问
- 定义Runnable接口的实现类，然后通过同一个类对象内的数据+同步锁实现同步[Thread_Learn9.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn9.java)

note: Runnable的方法是只能运行一次的，不能写成先获取锁，然后锁中执行while，那样其实各个线程只竞争了一次

### 同步锁机制
- 同步锁机制的代码写法
1. 方式一使用同步代码块的方式
```
synchronized(同步锁){
同步代码
}
```
同步监视器，就是锁； 可以使用任意一个对象，但是多个进程必须要共享这个对象，除了上面的锁定上面中的Runnable中的变量，也可以自己搞一个对象；[Thread_Learn10.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn10.java)

2. 方式二使用同步方法的方式
控制同时只有一个线程进入[Thread_Learn11.java](src%2Fmain%2Fjava%2Forg%2Fexample%2FThread_Learn11.java)

写在方法上的锁对象是this

- 同步机制的原理
同步机制的原理，其实就相当于给某段代码加“锁”，任何线程想要执行这段代码，都要先获得“锁”，我们称它为同步锁。
因为Java对象在堆中的数据分为分为对象头、实例变量、空白的填充。而对象头中包含：

* Mark Word：记录了和当前对象有关的GC、锁标记等信息。
* 指向类的指针：每一个对象需要记录它是由哪个类创建出来的。
* 数组长度（只有数组对象才有）

哪个线程获得了“同步锁”对象之后，”同步锁“对象就会记录这个线程的ID，这样其他线程就只能等待了，除非这个线程”释放“了锁对象，其他线程才能重新获得/占用”同步锁“对象。


- 同步锁机制的缺点
其实底层都是等待排队，串行，性能效率低下
